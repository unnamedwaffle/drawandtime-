<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw & Time - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        accent: '#FF6B6B',
                        secondary: '#4ECDC4',
                        warning: '#FFE66D',
                        success: '#95E1D3'
                    }
                }
            }
        }
    </script>
    <style>
        .drawing-canvas {
            touch-action: none;
            cursor: crosshair;
        }
        
        /* Allow scrolling normally, prevent only during active drawing */
        body.drawing-active {
            overflow: hidden;
            touch-action: none;
        }
        
        .btn-primary {
            @apply bg-gradient-to-r from-primary to-purple-600 hover:from-purple-600 hover:to-primary text-white font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-lg;
        }
        .btn-secondary {
            @apply bg-gradient-to-r from-gray-200 to-gray-300 dark:from-gray-700 dark:to-gray-600 hover:from-gray-300 hover:to-gray-200 dark:hover:from-gray-600 dark:hover:to-gray-700 text-gray-800 dark:text-gray-200 font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen">
    <!-- Setup Screen -->
    <div id="setupScreen" class="container mx-auto px-4 py-8 max-w-2xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-primary mb-4">Draw & Time - Enhanced</h1>
            <p class="text-lg text-gray-600 dark:text-gray-400">Get a random prompt and draw with professional tools!</p>
            <div class="flex justify-center gap-4 mt-6">
                <button id="tutorialBtn" class="bg-gradient-to-r from-secondary to-teal-500 hover:from-teal-500 hover:to-secondary text-white font-medium py-2 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">
                    üìö Drawing Tutorial
                </button>
                <button id="aboutBtn" class="bg-gradient-to-r from-warning to-yellow-500 hover:from-yellow-500 hover:to-warning text-white font-medium py-2 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">
                    ‚ÑπÔ∏è About
                </button>
            </div>
        </div>

        <div class="bg-gradient-to-br from-accent/10 to-secondary/10 dark:from-accent/20 dark:to-secondary/20 border-2 border-accent/30 rounded-xl p-6 mb-6 shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-accent">üé® Drawing Prompt</h2>
            <div id="promptDisplay" class="text-2xl font-medium text-primary mb-4 min-h-[3rem] flex items-center justify-center border-3 border-dashed border-secondary rounded-lg p-4 bg-white/50 dark:bg-gray-700/50">
                Click "Get Prompt" to start!
            </div>
            <button id="getPromptBtn" class="btn-primary w-full">üé≤ Get Random Prompt</button>
        </div>

        <div class="bg-gradient-to-br from-warning/10 to-success/10 dark:from-warning/20 dark:to-success/20 border-2 border-warning/30 rounded-xl p-6 mb-6 shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-warning">‚è∞ Timer Settings</h2>
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                <button class="timer-btn bg-gradient-to-r from-secondary to-cyan-400 hover:from-cyan-400 hover:to-secondary text-white font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-time="30">30s</button>
                <button class="timer-btn bg-gradient-to-r from-success to-green-400 hover:from-green-400 hover:to-success text-white font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-time="60">1m</button>
                <button class="timer-btn bg-gradient-to-r from-warning to-yellow-400 hover:from-yellow-400 hover:to-warning text-white font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-time="120">2m</button>
                <button class="timer-btn bg-gradient-to-r from-accent to-pink-400 hover:from-pink-400 hover:to-accent text-white font-medium py-3 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-time="300">5m</button>
            </div>
            <div class="mt-4">
                <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Custom time (seconds):</label>
                <input type="number" id="customTime" min="10" max="3600" placeholder="Enter seconds..." 
                       class="w-full px-4 py-3 text-base border-2 border-secondary/30 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-secondary focus:border-secondary transition-all duration-300">
            </div>
        </div>

        <div class="bg-gradient-to-br from-primary/10 to-secondary/10 dark:from-primary/20 dark:to-secondary/20 border-2 border-primary/30 rounded-xl p-6 mb-6 shadow-lg">
            <h2 class="text-xl font-semibold mb-4 text-primary">üìè Canvas Size</h2>
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4">
                <button class="canvas-btn bg-gradient-to-r from-primary to-purple-500 hover:from-purple-500 hover:to-primary text-white font-medium py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-width="800" data-height="600">
                    Small<br><span class="text-xs">800√ó600</span>
                </button>
                <button class="canvas-btn bg-gradient-to-r from-accent to-pink-500 hover:from-pink-500 hover:to-accent text-white font-medium py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-width="1200" data-height="900">
                    Medium<br><span class="text-xs">1200√ó900</span>
                </button>
                <button class="canvas-btn bg-gradient-to-r from-secondary to-teal-500 hover:from-teal-500 hover:to-secondary text-white font-medium py-3 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md" data-width="1600" data-height="1200">
                    Large<br><span class="text-xs">1600√ó1200</span>
                </button>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                <div>
                    <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Width (px):</label>
                    <input type="number" id="customWidth" min="400" max="3000" placeholder="Enter width..." 
                           class="w-full px-4 py-3 text-base border-2 border-primary/30 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-primary transition-all duration-300">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2 text-gray-700 dark:text-gray-300">Height (px):</label>
                    <input type="number" id="customHeight" min="300" max="3000" placeholder="Enter height..." 
                           class="w-full px-4 py-3 text-base border-2 border-primary/30 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-primary transition-all duration-300">
                </div>
            </div>
        </div>

        <button id="startDrawingBtn" class="btn-primary w-full text-lg" disabled>
            Start Drawing Session
        </button>
    </div>

    <!-- Drawing Screen -->
    <div id="drawingScreen" class="hidden">
        <!-- Header with timer and controls -->
        <div class="bg-gradient-to-r from-primary/10 to-accent/10 dark:from-primary/20 dark:to-accent/20 border-b-4 border-gradient-to-r from-primary to-accent px-4 py-3">
            <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                <div class="text-center sm:text-left">
                    <div id="currentPrompt" class="font-medium text-lg text-primary">üéØ</div>
                    <div id="timerDisplay" class="text-2xl font-bold text-accent"></div>
                </div>
                <div class="flex gap-2">
                    <button id="clearBtn" class="bg-gradient-to-r from-warning to-orange-400 hover:from-orange-400 hover:to-warning text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">üóëÔ∏è Clear</button>
                    <button id="stopDrawingBtn" class="bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-500 text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">‚èπÔ∏è Stop</button>
                </div>
            </div>
        </div>

        <!-- Enhanced Drawing Tools -->
        <div class="bg-gradient-to-r from-secondary/20 to-success/20 dark:from-secondary/30 dark:to-success/30 border-b-2 border-secondary px-4 py-3">
            <!-- Tool Selection -->
            <div class="flex items-center justify-center gap-2 mb-4 flex-wrap">
                <button id="brushTool" class="tool-btn bg-primary text-white px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    üñåÔ∏è Brush
                </button>
                <button id="eraserTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    üßΩ Eraser
                </button>
                <button id="eyedropperTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    üíß Dropper
                </button>
                <button id="lineTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    üìè Line
                </button>
                <button id="rectangleTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    ‚¨ú Rectangle
                </button>
                <button id="circleTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    ‚≠ï Circle
                </button>
                <button id="textTool" class="tool-btn bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 px-3 py-2 rounded-lg font-medium transition-all duration-300 transform hover:scale-105 shadow-md text-sm">
                    üìù Text
                </button>
            </div>

            <!-- Action Buttons -->
            <div class="flex items-center justify-center gap-2 mb-4 flex-wrap">
                <button id="undoBtn" class="bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Undo (Ctrl+Z)">
                    ‚Ü∂ Undo
                </button>
                <button id="redoBtn" class="bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Redo (Ctrl+Y)">
                    ‚Ü∑ Redo
                </button>
                <button id="zoomInBtn" class="bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Zoom In (+)">
                    üîç Zoom+
                </button>
                <button id="zoomOutBtn" class="bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Zoom Out (-)">
                    üîç Zoom-
                </button>
                <button id="resetZoomBtn" class="bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Reset Zoom (0)">
                    üéØ Reset
                </button>
                <button id="gridToggleBtn" class="bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-500 text-white font-medium py-2 px-3 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md text-sm" title="Toggle Grid (G)">
                    üìã Grid
                </button>
            </div>

            <!-- Tool Settings -->
            <div class="flex items-center justify-center gap-4 flex-wrap">
                <!-- Brush/Eraser Size -->
                <div class="flex items-center gap-3 bg-white/70 dark:bg-gray-700/70 rounded-lg px-3 py-2">
                    <label class="text-sm font-medium text-primary" id="sizeLabel">üñåÔ∏è Size:</label>
                    <input type="range" id="brushSize" min="1" max="50" value="5" 
                           class="w-20 h-3 bg-gradient-to-r from-secondary to-accent rounded-lg appearance-none cursor-pointer">
                    <span id="brushSizeValue" class="text-sm font-bold text-accent w-8 bg-white/50 rounded px-2 py-1">5</span>
                </div>

                <!-- Brush Type -->
                <div id="brushTypeContainer" class="flex items-center gap-3 bg-white/70 dark:bg-gray-700/70 rounded-lg px-3 py-2">
                    <label class="text-sm font-medium text-primary">‚úèÔ∏è Brush:</label>
                    <select id="brushType" class="bg-transparent text-sm font-medium text-accent border-none outline-none cursor-pointer">
                        <option value="round">Round</option>
                        <option value="square">Square</option>
                        <option value="soft">Soft</option>
                        <option value="spray">Spray</option>
                    </select>
                </div>

                <!-- Color Picker -->
                <div id="colorContainer" class="flex items-center gap-3 bg-white/70 dark:bg-gray-700/70 rounded-lg px-3 py-2">
                    <label class="text-sm font-medium text-primary">üé® Color:</label>
                    <input type="color" id="brushColor" value="#000000" 
                           class="w-10 h-10 border-3 border-white rounded-full cursor-pointer shadow-lg">
                </div>

                <!-- RGB Inputs -->
                <div id="rgbContainer" class="flex items-center gap-2 bg-white/70 dark:bg-gray-700/70 rounded-lg px-3 py-2">
                    <label class="text-xs font-medium text-primary">RGB:</label>
                    <div class="flex gap-1">
                        <input type="number" id="redValue" min="0" max="255" value="0" 
                               class="w-12 text-xs text-center border border-gray-300 rounded px-1 py-1" placeholder="R">
                        <input type="number" id="greenValue" min="0" max="255" value="0" 
                               class="w-12 text-xs text-center border border-gray-300 rounded px-1 py-1" placeholder="G">
                        <input type="number" id="blueValue" min="0" max="255" value="0" 
                               class="w-12 text-xs text-center border border-gray-300 rounded px-1 py-1" placeholder="B">
                    </div>
                </div>
            </div>

            <!-- Current Color Display -->
            <div class="flex justify-center mt-3">
                <div class="flex items-center gap-2 bg-white/70 dark:bg-gray-700/70 rounded-lg px-3 py-2">
                    <span class="text-xs font-medium text-primary">Current:</span>
                    <div id="currentColorDisplay" class="w-8 h-8 border-2 border-white rounded-full shadow-md" style="background-color: #000000;"></div>
                    <span id="currentColorHex" class="text-xs font-mono text-accent">#000000</span>
                </div>
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="flex-1 overflow-auto p-4" style="height: calc(100vh - 300px);">
            <canvas id="drawingCanvas" class="drawing-canvas block mx-auto border-4 border-gray-400 dark:border-gray-500 rounded-lg shadow-lg" style="touch-action: none;"></canvas>
        </div>
    </div>

    <!-- Continue Modal -->
    <div id="continueModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-sm w-full">
            <h3 class="text-xl font-semibold mb-4">Time's Up!</h3>
            <p class="text-gray-600 dark:text-gray-400 mb-6">Would you like to continue drawing or finish your artwork?</p>
            <div class="flex gap-3">
                <button id="continueDrawingBtn" class="btn-secondary flex-1">Continue</button>
                <button id="finishDrawingBtn" class="btn-primary flex-1">Finish</button>
            </div>
        </div>
    </div>

    <!-- Save Modal -->
    <div id="saveModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-sm w-full">
            <h3 class="text-xl font-semibold mb-4">Save Your Drawing</h3>
            <p class="text-gray-600 dark:text-gray-400 mb-6">Would you like to save your artwork as a JPG file?</p>
            <div class="flex gap-3">
                <button id="dontSaveBtn" class="btn-secondary flex-1">Don't Save</button>
                <button id="saveDrawingBtn" class="btn-primary flex-1">Save JPG</button>
            </div>
        </div>
    </div>

    <!-- Tutorial Screen -->
    <div id="tutorialScreen" class="hidden container mx-auto px-4 py-8 max-w-4xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-primary mb-4">üé® Drawing Tutorial & Tips</h1>
            <p class="text-lg text-gray-600 dark:text-gray-400">Master the art of quick sketching and time-based drawing!</p>
            <button id="backToMainBtn" class="mt-4 bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-500 text-white font-medium py-2 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">
                ‚Üê Back to Main
            </button>
        </div>

        <div class="grid gap-8">
            <!-- Getting Started -->
            <div class="bg-gradient-to-br from-primary/10 to-purple-100 dark:from-primary/20 dark:to-purple-900 border-2 border-primary/30 rounded-xl p-6 shadow-lg">
                <h2 class="text-2xl font-bold text-primary mb-4 flex items-center">
                    üöÄ Getting Started
                </h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-accent">Quick Setup Tips</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Start with 1-2 minute sessions to build confidence</li>
                            <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Use medium canvas size (1200√ó900) for most prompts</li>
                            <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Enable grid (G key) for better proportions</li>
                            <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Keep brush size between 3-8 for sketching</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-accent">Essential Tools</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-secondary mr-2">üñåÔ∏è</span><strong>Brush (B):</strong> Primary drawing tool</li>
                            <li class="flex items-start"><span class="text-warning mr-2">üßΩ</span><strong>Eraser (E):</strong> Clean up mistakes</li>
                            <li class="flex items-start"><span class="text-success mr-2">üìè</span><strong>Line (L):</strong> Straight edges and structure</li>
                            <li class="flex items-start"><span class="text-accent mr-2">‚¨ú</span><strong>Shapes (R/C):</strong> Quick geometric forms</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Mobile & Tablet Tips -->
            <div class="bg-gradient-to-br from-blue-100 to-cyan-100 dark:from-blue-900 dark:to-cyan-900 border-2 border-blue-300 dark:border-blue-600 rounded-xl p-6 shadow-lg">
                <h2 class="text-2xl font-bold text-blue-600 dark:text-blue-400 mb-4 flex items-center">
                    üì± Mobile & Tablet Drawing Tips
                </h2>
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-primary">Touch Drawing Techniques</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-blue-500 mr-2">üì±</span><strong>Single Touch:</strong> Use one finger for precise control</li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">‚úã</span><strong>Palm Rejection:</strong> Rest your palm naturally while drawing</li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">üîÑ</span><strong>Smooth Movements:</strong> Make flowing gestures for better lines</li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">üìê</span><strong>Screen Angle:</strong> Tilt your device for comfortable drawing</li>
                        </ul>
                        
                        <h3 class="text-lg font-semibold mb-3 mt-6 text-primary">‚úÖ Eraser Fixed for Android Tablets!</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-green-500 mr-2">üßΩ</span>Eraser now works reliably on ALL devices including Android tablets</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">ü§ñ</span>Special Android tablet detection and enhanced eraser mode</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">üëÜ</span>Use firm, deliberate strokes when erasing</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">‚ö™</span>Start with larger eraser sizes for broad removal</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">üéØ</span>Switch to smaller sizes for detail work</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-primary">Scroll & Navigation</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-green-500 mr-2">‚úÖ</span>Drawing is now protected from accidental scrolling</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">üîí</span>Canvas content won't disappear when scrolling</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">üé®</span>Drawing areas prevent page movement automatically</li>
                            <li class="flex items-start"><span class="text-green-500 mr-2">üìè</span>Use zoom controls for detailed work</li>
                        </ul>

                        <h3 class="text-lg font-semibold mb-3 mt-6 text-primary">Tool Selection</h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li class="flex items-start"><span class="text-purple-500 mr-2">üñåÔ∏è</span>Tap tool buttons directly for quick switching</li>
                            <li class="flex items-start"><span class="text-purple-500 mr-2">üéõÔ∏è</span>Adjust brush size with the slider</li>
                            <li class="flex items-start"><span class="text-purple-500 mr-2">üé®</span>Use color picker for quick color changes</li>
                            <li class="flex items-start"><span class="text-purple-500 mr-2">üíß</span>Eyedropper works with single tap</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- About Screen -->
    <div id="aboutScreen" class="hidden container mx-auto px-4 py-8 max-w-2xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-primary mb-4">About Draw & Time</h1>
            <button id="backToMainFromAboutBtn" class="bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-500 text-white font-medium py-2 px-6 rounded-lg transition-all duration-300 transform hover:scale-105 shadow-md">
                ‚Üê Back to Main
            </button>
        </div>

        <div class="bg-gradient-to-br from-primary/10 to-secondary/10 dark:from-primary/20 dark:to-secondary/20 border-2 border-primary/30 rounded-xl p-6 shadow-lg">
            <h2 class="text-2xl font-bold text-primary mb-4">üé® What is Draw & Time?</h2>
            <p class="text-gray-700 dark:text-gray-300 mb-4">
                Draw & Time is a creative drawing application designed to improve your sketching skills through timed challenges. 
                The app combines the pressure of time limits with random prompts to push your artistic boundaries and develop 
                quick observational skills.
            </p>
            
            <h3 class="text-xl font-semibold text-accent mb-3">‚ú® Features</h3>
            <ul class="space-y-2 text-gray-700 dark:text-gray-300 mb-6">
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>120+ diverse drawing prompts</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Professional drawing tools (brush, eraser, shapes, text)</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Multiple brush types and customizable settings</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>‚úÖ <strong>Fixed eraser that works on all devices!</strong></li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Undo/Redo system with 50-step history</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Zoom and pan controls for detailed work</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Grid overlay for better proportions</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Keyboard shortcuts for efficient workflow</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Save drawings as JPG with embedded prompt info</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Dark mode support</li>
                <li class="flex items-start"><span class="text-primary mr-2">‚Ä¢</span>Enhanced touch and mouse support</li>
            </ul>

            <h3 class="text-xl font-semibold text-accent mb-3">üîß Recent Improvements</h3>
            <ul class="space-y-2 text-gray-700 dark:text-gray-300 mb-6">
                <li class="flex items-start"><span class="text-success mr-2">‚úÖ</span><strong>Android Tablet Eraser Fixed:</strong> Special implementation for Android tablets now working perfectly</li>
                <li class="flex items-start"><span class="text-success mr-2">‚úÖ</span><strong>Device Detection:</strong> Automatically detects and optimizes for different devices</li>
                <li class="flex items-start"><span class="text-success mr-2">‚úÖ</span><strong>Better Touch Support:</strong> Enhanced drawing experience on tablets and phones</li>
                <li class="flex items-start"><span class="text-success mr-2">‚úÖ</span><strong>Improved Performance:</strong> Smoother drawing and better responsiveness</li>
                <li class="flex items-start"><span class="text-success mr-2">‚úÖ</span><strong>Cross-Device Compatibility:</strong> Consistent experience across all platforms</li>
            </ul>

            <h3 class="text-xl font-semibold text-accent mb-3">üéØ Why Timed Drawing?</h3>
            <p class="text-gray-700 dark:text-gray-300 mb-4">
                Timed drawing exercises help artists develop several crucial skills:
            </p>
            <ul class="space-y-2 text-gray-700 dark:text-gray-300 mb-6">
                <li class="flex items-start"><span class="text-secondary mr-2">‚Ä¢</span><strong>Quick Decision Making:</strong> Learn to make artistic choices rapidly</li>
                <li class="flex items-start"><span class="text-secondary mr-2">‚Ä¢</span><strong>Essential Observation:</strong> Focus on what's most important in a subject</li>
                <li class="flex items-start"><span class="text-secondary mr-2">‚Ä¢</span><strong>Confidence Building:</strong> Overcome the fear of "imperfect" drawings</li>
                <li class="flex items-start"><span class="text-secondary mr-2">‚Ä¢</span><strong>Gestural Fluency:</strong> Develop natural, flowing line work</li>
                <li class="flex items-start"><span class="text-secondary mr-2">‚Ä¢</span><strong>Creative Problem Solving:</strong> Find innovative ways to represent complex subjects</li>
            </ul>

            <h3 class="text-xl font-semibold text-accent mb-3">üí° Tips for Success</h3>
            <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                <li class="flex items-start"><span class="text-success mr-2">‚Ä¢</span>Start with longer time limits and gradually decrease</li>
                <li class="flex items-start"><span class="text-success mr-2">‚Ä¢</span>Focus on capturing the essence rather than perfection</li>
                <li class="flex items-start"><span class="text-success mr-2">‚Ä¢</span>Practice the same prompt multiple times to see improvement</li>
                <li class="flex items-start"><span class="text-success mr-2">‚Ä¢</span>Use the tutorial section to learn specific techniques</li>
                <li class="flex items-start"><span class="text-success mr-2">‚Ä¢</span>Don't be afraid to experiment with different tools and styles</li>
            </ul>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Drawing prompts
        const prompts = [
            "Animal", "Vehicle", "Food", "Building", "Plant", "Technology",
            "Sea Creature", "Musical Instrument", "Tool", "Furniture", "Toy",
            "Weather", "Sport", "Clothing", "Bird", "Insect", "Machine",
            "Fruit", "Vegetable", "Landscape", "Monster", "Robot", "Castle",
            "Bridge", "Mountain", "Forest", "Desert", "City", "Space",
            "Ocean", "River", "Tree", "Flower", "Computer", "Phone",
            "Car", "Airplane", "Boat", "House", "School", "Park",
            "Face", "Portrait", "Character", "Superhero", "Villain", "Wizard",
            "Dragon", "Unicorn", "Fantasy Creature", "Alien", "Ghost", "Angel",
            "Demon", "Warrior", "Knight", "Princess", "King", "Queen",
            "Chef", "Doctor", "Teacher", "Scientist", "Artist", "Musician",
            "Dancer", "Athlete", "Pirate", "Ninja", "Cowboy", "Astronaut",
            "Holiday", "Party", "Celebration", "Festival", "Wedding", "Birthday",
            "Christmas", "Halloween", "Easter", "Thanksgiving", "New Year",
            "Spring", "Summer", "Autumn", "Winter", "Sunrise", "Sunset",
            "Rainbow", "Storm", "Lightning", "Snow", "Rain", "Cloud",
            "Star", "Moon", "Sun", "Planet", "Galaxy", "Comet",
            "Jewelry", "Crown", "Ring", "Necklace", "Treasure", "Gold",
            "Silver", "Diamond", "Ruby", "Emerald", "Pearl", "Crystal",
            "Book", "Library", "School", "Classroom", "Laboratory", "Hospital",
            "Restaurant", "Cafe", "Market", "Store", "Factory", "Farm",
            "Garden", "Playground", "Stadium", "Theater", "Museum", "Gallery",
            "Beach", "Island", "Lake", "Waterfall", "Cave", "Valley",
            "Hill", "Cliff", "Volcano", "Glacier", "Jungle", "Safari",
            "Zoo", "Aquarium", "Circus", "Carnival", "Fair", "Parade"
        ];

        // Enhanced App state
        let currentPrompt = '';
        let selectedTime = 0;
        let timer = null;
        let timeLeft = 0;
        let drawing = false;

        // Enhanced Drawing state
        let currentTool = 'brush'; // 'brush', 'eraser', 'eyedropper', 'line', 'rectangle', 'circle', 'text'
        let currentBrushType = 'round';
        let currentColor = '#000000';

        // Enhanced Canvas state
        let canvasWidth = 1200;
        let canvasHeight = 900;
        let startTime = null;
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;

        // Canvas setup
        let canvas, ctx;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const maxUndoSteps = 50;

        // Shape drawing state
        let isDrawingShape = false;
        let shapeStartX = 0;
        let shapeStartY = 0;
        let tempCanvas = null;
        let tempCtx = null;

        // Text tool state
        let textInput = null;

        // Grid functionality
        let gridVisible = false;

        // Enhanced eraser state for better device compatibility
        let lastErasePoint = null;
        let eraserContextState = null;
        let isAndroidTablet = false;
        let eraserTempCanvas = null;
        let eraserTempCtx = null;

        // DOM elements
        const setupScreen = document.getElementById('setupScreen');
        const drawingScreen = document.getElementById('drawingScreen');
        const promptDisplay = document.getElementById('promptDisplay');
        const getPromptBtn = document.getElementById('getPromptBtn');
        const timerBtns = document.querySelectorAll('.timer-btn');
        const customTimeInput = document.getElementById('customTime');
        const startDrawingBtn = document.getElementById('startDrawingBtn');
        const canvasBtns = document.querySelectorAll('.canvas-btn');
        const customWidthInput = document.getElementById('customWidth');
        const customHeightInput = document.getElementById('customHeight');
        const currentPromptEl = document.getElementById('currentPrompt');
        const timerDisplay = document.getElementById('timerDisplay');
        const clearBtn = document.getElementById('clearBtn');
        const stopDrawingBtn = document.getElementById('stopDrawingBtn');
        const continueModal = document.getElementById('continueModal');
        const saveModal = document.getElementById('saveModal');
        const brushSize = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const brushColor = document.getElementById('brushColor');
        
        // Tool elements
        const brushTool = document.getElementById('brushTool');
        const eraserTool = document.getElementById('eraserTool');
        const eyedropperTool = document.getElementById('eyedropperTool');
        const lineTool = document.getElementById('lineTool');
        const rectangleTool = document.getElementById('rectangleTool');
        const circleTool = document.getElementById('circleTool');
        const textTool = document.getElementById('textTool');
        const brushType = document.getElementById('brushType');
        const sizeLabel = document.getElementById('sizeLabel');
        const brushTypeContainer = document.getElementById('brushTypeContainer');
        const colorContainer = document.getElementById('colorContainer');
        const rgbContainer = document.getElementById('rgbContainer');
        const redValue = document.getElementById('redValue');
        const greenValue = document.getElementById('greenValue');
        const blueValue = document.getElementById('blueValue');
        const currentColorDisplay = document.getElementById('currentColorDisplay');
        const currentColorHex = document.getElementById('currentColorHex');

        // Action buttons
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const gridToggleBtn = document.getElementById('gridToggleBtn');

        // Initialize
        function init() {
            detectAndroidTablet();
            setupCanvas();
            setupEventListeners();
            setupAndroidEraserFallback();
        }

        // Android tablet detection and setup
        function detectAndroidTablet() {
            const userAgent = navigator.userAgent.toLowerCase();
            const isAndroid = userAgent.includes('android');
            const isTablet = !userAgent.includes('mobile') && (
                window.innerWidth >= 768 || 
                screen.width >= 768 ||
                userAgent.includes('tablet')
            );
            
            isAndroidTablet = isAndroid && isTablet;
            
            // Set up special handling for Android tablets
            if (isAndroidTablet) {
                console.log('Android tablet detected - using enhanced eraser mode');
            }
        }

        function setupAndroidEraserFallback() {
            if (isAndroidTablet) {
                // Create a separate canvas for Android eraser operations
                eraserTempCanvas = document.createElement('canvas');
                eraserTempCtx = eraserTempCanvas.getContext('2d');
                
                // Configure for better Android compatibility
                if (eraserTempCtx.imageSmoothingEnabled !== undefined) {
                    eraserTempCtx.imageSmoothingEnabled = false;
                }
            }
        }

        function setupCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function resizeCanvas() {
            // Preserve existing canvas data if it exists
            let existingImageData = null;
            if (canvas && ctx && undoStack.length > 0) {
                existingImageData = canvas.toDataURL();
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            const container = canvas.parentElement;
            const containerWidth = window.innerWidth - 40;
            const containerHeight = window.innerHeight - 200;
            
            const scaleX = containerWidth / canvasWidth;
            const scaleY = containerHeight / canvasHeight;
            const scale = Math.min(scaleX, scaleY, 1);
            
            canvas.style.width = (canvasWidth * scale) + 'px';
            canvas.style.height = (canvasHeight * scale) + 'px';
            
            // Restore existing drawing or create white background
            if (existingImageData) {
                const img = new Image();
                img.onload = function() {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = existingImageData;
            } else {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Save initial state for undo only when first creating
                saveCanvasState();
            }
        }

        function setupEventListeners() {
            // Setup screen
            getPromptBtn.addEventListener('click', generatePrompt);
            timerBtns.forEach(btn => {
                btn.addEventListener('click', () => selectTime(parseInt(btn.dataset.time)));
            });
            customTimeInput.addEventListener('input', handleCustomTime);
            startDrawingBtn.addEventListener('click', startDrawing);

            // Canvas size selection
            canvasBtns.forEach(btn => {
                btn.addEventListener('click', () => selectCanvasSize(parseInt(btn.dataset.width), parseInt(btn.dataset.height)));
            });
            customWidthInput.addEventListener('input', handleCustomCanvasSize);
            customHeightInput.addEventListener('input', handleCustomCanvasSize);

            // Drawing screen
            clearBtn.addEventListener('click', clearCanvas);
            stopDrawingBtn.addEventListener('click', stopDrawing);
            
            // Canvas events with enhanced touch handling
            canvas.addEventListener('mousedown', startDrawingMouse);
            canvas.addEventListener('mousemove', drawMouse);
            canvas.addEventListener('mouseup', stopDrawingMouse);
            canvas.addEventListener('mouseout', stopDrawingMouse);
            
            // Enhanced touch event handling for tablet support
            canvas.addEventListener('touchstart', startDrawingTouch, { passive: false });
            canvas.addEventListener('touchmove', drawTouch, { passive: false });
            canvas.addEventListener('touchend', stopDrawingTouch, { passive: false });
            canvas.addEventListener('touchcancel', stopDrawingTouch, { passive: false });

            // Tool controls
            brushSize.addEventListener('input', updateBrushSize);
            brushColor.addEventListener('change', updateBrushColor);

            // Tool selection
            brushTool.addEventListener('click', () => selectTool('brush'));
            eraserTool.addEventListener('click', () => selectTool('eraser'));
            eyedropperTool.addEventListener('click', () => selectTool('eyedropper'));
            lineTool.addEventListener('click', () => selectTool('line'));
            rectangleTool.addEventListener('click', () => selectTool('rectangle'));
            circleTool.addEventListener('click', () => selectTool('circle'));
            textTool.addEventListener('click', () => selectTool('text'));

            // Action buttons
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            resetZoomBtn.addEventListener('click', resetZoom);
            gridToggleBtn.addEventListener('click', toggleGrid);

            // Brush type
            brushType.addEventListener('change', updateBrushType);

            // RGB inputs
            redValue.addEventListener('input', updateFromRGB);
            greenValue.addEventListener('input', updateFromRGB);
            blueValue.addEventListener('input', updateFromRGB);

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);

            // Modal buttons
            document.getElementById('continueDrawingBtn').addEventListener('click', continueDraw);
            document.getElementById('finishDrawingBtn').addEventListener('click', finishDrawing);
            document.getElementById('saveDrawingBtn').addEventListener('click', saveDrawing);
            document.getElementById('dontSaveBtn').addEventListener('click', dontSave);

            // Navigation buttons
            document.getElementById('tutorialBtn').addEventListener('click', showTutorial);
            document.getElementById('aboutBtn').addEventListener('click', showAbout);
            document.getElementById('backToMainBtn').addEventListener('click', showMain);
            document.getElementById('backToMainFromAboutBtn').addEventListener('click', showMain);
        }

        // Undo/Redo system
        function saveCanvasState() {
            if (undoStack.length >= maxUndoSteps) {
                undoStack.shift();
            }
            undoStack.push(canvas.toDataURL());
            redoStack = [];
        }

        function undo() {
            // Only allow undo if there are at least 2 states (initial + at least one drawing operation)
            if (undoStack.length > 2) {
                redoStack.push(undoStack.pop());
                const previousState = undoStack[undoStack.length - 1];
                restoreCanvasState(previousState);
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                undoStack.push(nextState);
                restoreCanvasState(nextState);
            }
        }

        function restoreCanvasState(imageData) {
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = imageData;
        }

        // Zoom functions
        function zoomIn() {
            zoomLevel = Math.min(zoomLevel * 1.2, 5);
            applyZoom();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel / 1.2, 0.1);
            applyZoom();
        }

        function resetZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
            applyZoom();
        }

        function applyZoom() {
            canvas.style.transform = `scale(${zoomLevel}) translate(${panX}px, ${panY}px)`;
        }

        // Grid functionality
        function toggleGrid() {
            gridVisible = !gridVisible;
            if (gridVisible) {
                drawGrid();
                gridToggleBtn.style.backgroundColor = '#10B981';
            } else {
                clearGrid();
                gridToggleBtn.style.backgroundColor = '';
            }
        }

        function drawGrid() {
            const gridSize = 20;
            ctx.save();
            ctx.strokeStyle = '#E5E5E5';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function clearGrid() {
            // Grid is overlay only, redraw canvas without it
        }

        // Keyboard shortcuts
        function handleKeyboardShortcuts(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        redo();
                        break;
                    case 's':
                        e.preventDefault();
                        saveDrawing();
                        break;
                }
            } else {
                switch(e.key.toLowerCase()) {
                    case 'b': selectTool('brush'); break;
                    case 'e': selectTool('eraser'); break;
                    case 'i': selectTool('eyedropper'); break;
                    case 'l': selectTool('line'); break;
                    case 'r': selectTool('rectangle'); break;
                    case 'c': selectTool('circle'); break;
                    case 't': selectTool('text'); break;
                    case 'g': toggleGrid(); break;
                    case '+':
                    case '=': zoomIn(); break;
                    case '-': zoomOut(); break;
                    case '0': resetZoom(); break;
                }
            }
        }

        // Shape drawing functions
        function startShapeDrawing(x, y) {
            saveCanvasState();
            isDrawingShape = true;
            shapeStartX = x;
            shapeStartY = y;
            
            if (!tempCanvas) {
                tempCanvas = document.createElement('canvas');
                tempCtx = tempCanvas.getContext('2d');
            }
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            tempCtx.drawImage(canvas, 0, 0);
        }

        function drawShape(endX, endY) {
            if (!isDrawingShape) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempCanvas, 0, 0);
            
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize.value;
            ctx.beginPath();
            
            const width = endX - shapeStartX;
            const height = endY - shapeStartY;
            
            switch(currentTool) {
                case 'line':
                    ctx.moveTo(shapeStartX, shapeStartY);
                    ctx.lineTo(endX, endY);
                    break;
                case 'rectangle':
                    ctx.rect(shapeStartX, shapeStartY, width, height);
                    break;
                case 'circle':
                    const radius = Math.sqrt(width * width + height * height);
                    ctx.arc(shapeStartX, shapeStartY, radius, 0, 2 * Math.PI);
                    break;
            }
            
            ctx.stroke();
        }

        function finishShape() {
            isDrawingShape = false;
        }

        // Text tool functions
        function addText(x, y) {
            if (textInput) {
                removeTextInput();
            }
            
            textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.placeholder = 'Enter text...';
            textInput.className = 'absolute bg-white border-2 border-primary rounded px-2 py-1 text-black z-50';
            textInput.style.left = (x + canvas.offsetLeft) + 'px';
            textInput.style.top = (y + canvas.offsetTop) + 'px';
            textInput.style.fontSize = brushSize.value + 'px';
            
            document.body.appendChild(textInput);
            textInput.focus();
            
            textInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    if (textInput.value.trim()) {
                        saveCanvasState();
                        ctx.fillStyle = currentColor;
                        ctx.font = `${brushSize.value}px Arial, sans-serif`;
                        ctx.fillText(textInput.value, x, y);
                    }
                    removeTextInput();
                } else if (e.key === 'Escape') {
                    removeTextInput();
                }
            });
            
            textInput.addEventListener('blur', function() {
                setTimeout(removeTextInput, 100);
            });
        }

        function removeTextInput() {
            if (textInput) {
                textInput.remove();
                textInput = null;
            }
        }

        // Rest of the functions remain the same as original...
        function generatePrompt() {
            currentPrompt = prompts[Math.floor(Math.random() * prompts.length)];
            promptDisplay.textContent = currentPrompt;
            checkCanStart();
        }

        function selectTime(time) {
            selectedTime = time;
            customTimeInput.value = '';
            
            timerBtns.forEach(btn => {
                btn.classList.remove('bg-primary', 'text-white');
                btn.classList.add('btn-secondary');
            });
            event.target.classList.remove('btn-secondary');
            event.target.classList.add('bg-primary', 'text-white');
            
            checkCanStart();
        }

        function selectCanvasSize(width, height) {
            canvasWidth = width;
            canvasHeight = height;
            customWidthInput.value = '';
            customHeightInput.value = '';
            
            canvasBtns.forEach(btn => {
                btn.classList.remove('ring-4', 'ring-primary');
            });
            event.target.classList.add('ring-4', 'ring-primary');
        }

        function handleCustomCanvasSize() {
            const width = parseInt(customWidthInput.value);
            const height = parseInt(customHeightInput.value);
            
            if (width >= 400 && height >= 300) {
                canvasWidth = width;
                canvasHeight = height;
                
                canvasBtns.forEach(btn => {
                    btn.classList.remove('ring-4', 'ring-primary');
                });
            }
        }

        function handleCustomTime() {
            const time = parseInt(customTimeInput.value);
            if (time >= 10) {
                selectedTime = time;
                
                timerBtns.forEach(btn => {
                    btn.classList.remove('bg-primary', 'text-white');
                    btn.classList.add('btn-secondary');
                });
                
                checkCanStart();
            }
        }

        function checkCanStart() {
            startDrawingBtn.disabled = !currentPrompt || selectedTime <= 0;
            if (!startDrawingBtn.disabled) {
                startDrawingBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                startDrawingBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function startDrawing() {
            setupScreen.classList.add('hidden');
            drawingScreen.classList.remove('hidden');
            
            currentPromptEl.textContent = currentPrompt;
            timeLeft = selectedTime;
            startTime = new Date();
            updateTimerDisplay();
            
            timer = setInterval(() => {
                timeLeft--;
                updateTimerDisplay();
                
                if (timeLeft <= 0) {
                    clearInterval(timer);
                    showContinueModal();
                }
            }, 1000);

            resizeCanvas();
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (timeLeft <= 10) {
                timerDisplay.classList.add('text-red-500');
            } else {
                timerDisplay.classList.remove('text-red-500');
            }
        }

        function clearCanvas() {
            saveCanvasState();
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function stopDrawing() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
            showSaveModal();
        }

        function showContinueModal() {
            continueModal.classList.remove('hidden');
        }

        function continueDraw() {
            continueModal.classList.add('hidden');
        }

        function finishDrawing() {
            continueModal.classList.add('hidden');
            showSaveModal();
        }

        function showSaveModal() {
            saveModal.classList.remove('hidden');
        }

        function saveDrawing() {
            const saveCanvas = document.createElement('canvas');
            const saveCtx = saveCanvas.getContext('2d');
            
            const infoBoxHeight = 80;
            saveCanvas.width = canvas.width;
            saveCanvas.height = canvas.height + infoBoxHeight;
            
            saveCtx.drawImage(canvas, 0, 0);
            
            saveCtx.fillStyle = 'white';
            saveCtx.fillRect(0, canvas.height, canvas.width, infoBoxHeight);
            
            saveCtx.strokeStyle = '#E5E5E5';
            saveCtx.lineWidth = 2;
            saveCtx.strokeRect(0, canvas.height, canvas.width, infoBoxHeight);
            
            const currentDate = startTime ? startTime.toLocaleString() : new Date().toLocaleString();
            const promptText = `Prompt: ${currentPrompt}`;
            const dateText = `Created: ${currentDate}`;
            
            saveCtx.fillStyle = '#333333';
            saveCtx.textAlign = 'left';
            
            saveCtx.font = 'bold 18px Arial, sans-serif';
            saveCtx.fillText(promptText, 20, canvas.height + 25);
            
            saveCtx.font = '14px Arial, sans-serif';
            saveCtx.fillText(dateText, 20, canvas.height + 50);
            
            const sizeText = `Canvas: ${canvas.width}√ó${canvas.height}px`;
            saveCtx.fillText(sizeText, 20, canvas.height + 70);
            
            const link = document.createElement('a');
            link.download = `drawing-${currentPrompt.replace(/[^a-z0-9]/gi, '_').toLowerCase()}-${Date.now()}.jpg`;
            link.href = saveCanvas.toDataURL('image/jpeg', 0.9);
            link.click();
            
            dontSave();
        }

        function dontSave() {
            saveModal.classList.add('hidden');
            resetApp();
        }

        function resetApp() {
            drawingScreen.classList.add('hidden');
            setupScreen.classList.remove('hidden');
            
            // Remove drawing active class from body
            document.body.classList.remove('drawing-active');
            
            currentPrompt = '';
            selectedTime = 0;
            promptDisplay.textContent = 'Click "Get Prompt" to start!';
            customTimeInput.value = '';
            
            timerBtns.forEach(btn => {
                btn.classList.remove('bg-primary', 'text-white');
                btn.classList.add('btn-secondary');
            });
            
            checkCanStart();
        }

        // Tool functions
        function selectTool(tool) {
            currentTool = tool;
            
            // Reset canvas context when switching tools
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            const allToolBtns = document.querySelectorAll('.tool-btn');
            allToolBtns.forEach(btn => {
                btn.classList.remove('bg-primary', 'text-white');
                btn.classList.add('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
            });
            
            let selectedBtn;
            switch(tool) {
                case 'brush': selectedBtn = brushTool; break;
                case 'eraser': selectedBtn = eraserTool; break;
                case 'eyedropper': selectedBtn = eyedropperTool; break;
                case 'line': selectedBtn = lineTool; break;
                case 'rectangle': selectedBtn = rectangleTool; break;
                case 'circle': selectedBtn = circleTool; break;
                case 'text': selectedBtn = textTool; break;
            }
            
            if (selectedBtn) {
                selectedBtn.classList.remove('bg-gray-300', 'dark:bg-gray-600', 'text-gray-700', 'dark:text-gray-300');
                selectedBtn.classList.add('bg-primary', 'text-white');
            }
            
            updateToolUI();
            updateCanvasCursor();
        }

        function updateToolUI() {
            if (currentTool === 'brush') {
                sizeLabel.textContent = 'üñåÔ∏è Size:';
                brushTypeContainer.style.display = 'flex';
                colorContainer.style.display = 'flex';
                rgbContainer.style.display = 'flex';
            } else if (currentTool === 'eraser') {
                sizeLabel.textContent = 'üßΩ Size:';
                brushTypeContainer.style.display = 'none';
                colorContainer.style.display = 'none';
                rgbContainer.style.display = 'none';
            } else if (currentTool === 'eyedropper') {
                sizeLabel.textContent = 'üíß Area:';
                brushTypeContainer.style.display = 'none';
                colorContainer.style.display = 'flex';
                rgbContainer.style.display = 'flex';
            } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                sizeLabel.textContent = 'üìè Width:';
                brushTypeContainer.style.display = 'none';
                colorContainer.style.display = 'flex';
                rgbContainer.style.display = 'flex';
            } else if (currentTool === 'text') {
                sizeLabel.textContent = 'üìù Size:';
                brushTypeContainer.style.display = 'none';
                colorContainer.style.display = 'flex';
                rgbContainer.style.display = 'flex';
            }
        }

        function updateCanvasCursor() {
            switch(currentTool) {
                case 'brush': canvas.style.cursor = 'crosshair'; break;
                case 'eraser': canvas.style.cursor = 'grab'; break;
                case 'eyedropper': canvas.style.cursor = 'cell'; break;
                case 'line':
                case 'rectangle':
                case 'circle': canvas.style.cursor = 'crosshair'; break;
                case 'text': canvas.style.cursor = 'text'; break;
                default: canvas.style.cursor = 'default';
            }
        }

        function updateBrushType() {
            currentBrushType = brushType.value;
        }

        function updateBrushSize() {
            brushSizeValue.textContent = brushSize.value;
        }

        function updateBrushColor() {
            currentColor = brushColor.value;
            updateColorDisplay();
            updateRGBFromHex();
        }

        function updateFromRGB() {
            const r = parseInt(redValue.value) || 0;
            const g = parseInt(greenValue.value) || 0;
            const b = parseInt(blueValue.value) || 0;
            
            currentColor = rgbToHex(r, g, b);
            brushColor.value = currentColor;
            updateColorDisplay();
        }

        function updateColorDisplay() {
            currentColorDisplay.style.backgroundColor = currentColor;
            currentColorHex.textContent = currentColor.toUpperCase();
        }

        function updateRGBFromHex() {
            const rgb = hexToRgb(currentColor);
            redValue.value = rgb.r;
            greenValue.value = rgb.g;
            blueValue.value = rgb.b;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r: 0, g: 0, b: 0};
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function getPixelColor(x, y) {
            const imageData = ctx.getImageData(x, y, 1, 1);
            const data = imageData.data;
            return rgbToHex(data[0], data[1], data[2]);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            return {
                x: (e.touches[0].clientX - rect.left) * scaleX,
                y: (e.touches[0].clientY - rect.top) * scaleY
            };
        }

        // Enhanced eraser functions with better device compatibility
        function setupEraserStyle() {
            // Store current context state
            eraserContextState = {
                fillStyle: ctx.fillStyle,
                strokeStyle: ctx.strokeStyle,
                lineWidth: ctx.lineWidth,
                lineCap: ctx.lineCap,
                lineJoin: ctx.lineJoin,
                globalCompositeOperation: ctx.globalCompositeOperation,
                shadowBlur: ctx.shadowBlur,
                shadowColor: ctx.shadowColor
            };
            
            // Set up eraser context with multiple fallbacks
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'rgba(0,0,0,1)'; // Use solid black for erasing
            ctx.fillStyle = 'rgba(0,0,0,1)';
            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        function restoreContextAfterEraser() {
            if (eraserContextState) {
                ctx.fillStyle = eraserContextState.fillStyle;
                ctx.strokeStyle = eraserContextState.strokeStyle;
                ctx.lineWidth = eraserContextState.lineWidth;
                ctx.lineCap = eraserContextState.lineCap;
                ctx.lineJoin = eraserContextState.lineJoin;
                ctx.globalCompositeOperation = eraserContextState.globalCompositeOperation;
                ctx.shadowBlur = eraserContextState.shadowBlur;
                ctx.shadowColor = eraserContextState.shadowColor;
            }
        }

        function performEraseOperation(x, y, isFirst = false) {
            const size = brushSize.value;
            
            if (isAndroidTablet) {
                // Special Android tablet eraser implementation
                performAndroidErase(x, y, isFirst);
            } else {
                // Standard eraser implementation for other devices
                performStandardErase(x, y, isFirst);
            }
            
            lastErasePoint = { x, y };
        }

        function performStandardErase(x, y, isFirst) {
            const size = brushSize.value;
            
            // Method 1: Circle fill for immediate response
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0,0,0,1)';
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            // Method 2: Line stroke for connecting points (if not first point)
            if (!isFirst && lastErasePoint) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(lastErasePoint.x, lastErasePoint.y);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.restore();
            }
        }

        function performAndroidErase(x, y, isFirst) {
            const size = brushSize.value;
            
            // Android-specific eraser: Use a simpler approach that works better on Android
            // Just use multiple erase operations with different techniques
            
            // Method 1: Direct destination-out circle
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0,0,0,1)';
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            // Method 2: If not first point, connect with line
            if (!isFirst && lastErasePoint) {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(lastErasePoint.x, lastErasePoint.y);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.restore();
            }
            
            // Method 3: Additional circle overlay for Android tablets (ensures visibility)
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.beginPath();
            ctx.arc(x, y, size / 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            // Force visual refresh for Android rendering issues
            if (canvas && canvas.getContext) {
                const tempImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                requestAnimationFrame(() => {
                    ctx.putImageData(tempImageData, 0, 0);
                });
            }
        }

        function startDrawingMouse(e) {
            const pos = getMousePos(e);
            
            if (currentTool === 'eyedropper') {
                const pickedColor = getPixelColor(pos.x, pos.y);
                currentColor = pickedColor;
                brushColor.value = currentColor;
                updateColorDisplay();
                updateRGBFromHex();
                return;
            }
            
            if (currentTool === 'text') {
                addText(pos.x, pos.y);
                return;
            }
            
            if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                startShapeDrawing(pos.x, pos.y);
                return;
            }
            
            // Save canvas state for undo functionality
            if (currentTool === 'brush' || currentTool === 'eraser') {
                saveCanvasState();
            }
            
            drawing = true;
            
            if (currentTool === 'brush') {
                setupBrushStyle();
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            } else if (currentTool === 'eraser') {
                setupEraserStyle();
                lastErasePoint = null;
                performEraseOperation(pos.x, pos.y, true);
            }
        }

        function drawMouse(e) {
            if (!drawing && !isDrawingShape) return;
            e.preventDefault();
            
            const pos = getMousePos(e);
            
            if (isDrawingShape) {
                drawShape(pos.x, pos.y);
                return;
            }
            
            if (currentTool === 'brush') {
                drawWithBrush(pos.x, pos.y);
            } else if (currentTool === 'eraser') {
                performEraseOperation(pos.x, pos.y, false);
            }
        }

        function stopDrawingMouse() {
            drawing = false;
            lastErasePoint = null;
            
            if (isDrawingShape) {
                finishShape();
            }
            
            if (currentTool === 'brush') {
                ctx.beginPath();
            } else if (currentTool === 'eraser') {
                restoreContextAfterEraser();
            }
        }

        // Enhanced touch event handlers with improved eraser support
        function startDrawingTouch(e) {
            // Prevent all default behaviors including scrolling
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Only handle single touch (ignore multi-touch)
            if (e.touches.length !== 1) return;
            
            // Add drawing-active class to prevent body scrolling
            document.body.classList.add('drawing-active');
            
            const pos = getTouchPos(e);
            
            if (currentTool === 'eyedropper') {
                const pickedColor = getPixelColor(pos.x, pos.y);
                currentColor = pickedColor;
                brushColor.value = currentColor;
                updateColorDisplay();
                updateRGBFromHex();
                document.body.classList.remove('drawing-active');
                return;
            }
            
            if (currentTool === 'text') {
                addText(pos.x, pos.y);
                document.body.classList.remove('drawing-active');
                return;
            }
            
            if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle') {
                startShapeDrawing(pos.x, pos.y);
                return;
            }
            
            // Save canvas state for undo functionality
            if (currentTool === 'brush' || currentTool === 'eraser') {
                saveCanvasState();
            }
            
            drawing = true;
            
            if (currentTool === 'brush') {
                setupBrushStyle();
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            } else if (currentTool === 'eraser') {
                setupEraserStyle();
                lastErasePoint = null;
                performEraseOperation(pos.x, pos.y, true);
            }
        }

        function drawTouch(e) {
            if (!drawing && !isDrawingShape) return;
            
            // Prevent all default behaviors
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Only handle single touch
            if (e.touches.length !== 1) return;
            
            const pos = getTouchPos(e);
            
            if (isDrawingShape) {
                drawShape(pos.x, pos.y);
                return;
            }
            
            if (currentTool === 'brush') {
                drawWithBrush(pos.x, pos.y);
            } else if (currentTool === 'eraser') {
                performEraseOperation(pos.x, pos.y, false);
            }
        }

        function stopDrawingTouch(e) {
            // Prevent all default behaviors
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Remove drawing-active class to allow normal scrolling
            document.body.classList.remove('drawing-active');
            
            drawing = false;
            lastErasePoint = null;
            
            if (isDrawingShape) {
                finishShape();
            }
            
            if (currentTool === 'brush') {
                ctx.beginPath();
            } else if (currentTool === 'eraser') {
                restoreContextAfterEraser();
            }
        }

        function setupBrushStyle() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.lineWidth = brushSize.value;
            ctx.strokeStyle = currentColor;
            ctx.shadowBlur = 0; // Reset any shadow
            
            if (currentBrushType === 'round') {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
            } else if (currentBrushType === 'square') {
                ctx.lineCap = 'square';
                ctx.lineJoin = 'miter';
            } else if (currentBrushType === 'soft') {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = currentColor;
                ctx.shadowBlur = brushSize.value / 3;
            }
        }

        function drawWithBrush(x, y) {
            if (currentBrushType === 'spray') {
                drawSprayBrush(x, y);
            } else {
                ctx.lineTo(x, y);
                ctx.stroke();
                
                if (currentBrushType !== 'soft') {
                    ctx.shadowBlur = 0;
                }
            }
        }

        function drawSprayBrush(x, y) {
            const density = 20;
            const radius = brushSize.value / 2;
            
            ctx.save();
            ctx.fillStyle = currentColor;
            
            for (let i = 0; i < density; i++) {
                const offsetX = (Math.random() - 0.5) * radius * 2;
                const offsetY = (Math.random() - 0.5) * radius * 2;
                
                ctx.beginPath();
                ctx.arc(x + offsetX, y + offsetY, 1, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }

        // Navigation functions
        function showTutorial() {
            setupScreen.classList.add('hidden');
            document.getElementById('tutorialScreen').classList.remove('hidden');
            document.getElementById('aboutScreen').classList.add('hidden');
        }

        function showAbout() {
            setupScreen.classList.add('hidden');
            document.getElementById('tutorialScreen').classList.add('hidden');
            document.getElementById('aboutScreen').classList.remove('hidden');
        }

        function showMain() {
            setupScreen.classList.remove('hidden');
            document.getElementById('tutorialScreen').classList.add('hidden');
            document.getElementById('aboutScreen').classList.add('hidden');
        }

        // Initialize app
        init();
    </script>
</body>
</html>
